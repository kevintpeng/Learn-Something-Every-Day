<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <meta http-equiv="Content-Style-Type" content="text/css">
  <meta name="generator" content="pandoc">
  
  <style type="text/css">code{white-space: pre;}</style>
  <link rel="stylesheet" href="/style.css" type="text/css">
          <title>Consensus Problem</title>
</head>
<body>

<h1 id="consensus-problem">Consensus Problem</h1>          <a href="index.html">Back to Computer-Science-Concepts</a>
<div id="TOC">

<ul>
<li><a href="#two-phase-commit">Two-Phase Commit</a></li>
<li><a href="#three-phase-commit">Three-Phase Commit</a></li>
<li>
<a href="#paxos----source">Paxos -- </a><a href="http://the-paper-trail.org/blog/consensus-protocols-paxos/">source</a>
</li>
<li>
<a href="#phase-1a-prepare----source">Phase 1a: Prepare -- </a><a href="https://en.wikipedia.org/wiki/Paxos_(computer_science)#Basic_Paxos">source</a>
</li>
<li><a href="#phase-1b-promise">Phase 1b: Promise</a></li>
<li><a href="#phase-2a-accept-request">Phase 2a: Accept Request</a></li>
<li><a href="#phase-2b-accepted">Phase 2b: Accepted</a></li>
<li><a href="#raft">Raft</a></li>
</ul>
</div>
<p>A fundamental problem in distributed computing, which requires agreement among a number of processes for a single data value.</p>
<ul>
<li>consensus protocols must be fault tolerant, to deal with unreliability</li>
<li>a candidate value is put forth, and a consensus value is agreed upon (deciding whether to commit a database transaction, synchronous clocks ...)</li>
<li>a consensus protocol is correct if <strong>agreement</strong> is met, the value is <strong>proposed</strong> by some node, and all nodes eventually decide (<strong>terminate</strong>)</li>
</ul>
<h3 id="two-phase-commit">Two-Phase Commit</h3>
<ol>
<li>A self assigned coordinator contacts every node, propose a value and gather boolean responses</li>
<li>if everyone agrees, commit</li>
</ol>
<p>Solves consensus problem assuming no failures.</p>
<ul>
<li>If a coordinator crashes without sending all proposal messages, some nodes are blocked waiting for a response to the consensus</li>
<li>If coordinator crashes sending half of commits, then some nodes are updated, others are blocked</li>
</ul>
<h3 id="three-phase-commit">Three-Phase Commit</h3>
<p>Similar to 2PC. Second phase of 2PC has two sub-phases.</p>
<ol>
<li>Coordinator proposes</li>
<li>If everyone agrees, prepare to commit, communicating the result of the vote to every node</li>
<li>commit (or abort if delivery of prepare to commit to any node fails)</li>
</ol>
<ul>
<li>If the coordinator crashes at any point, from 2 onwards, now any node can take over and coordinate.</li>
<li>if a node has commited, we know that all nodes have prepared to commit already</li>
</ul>
<p><strong>Problem</strong>: network partitioning can cause inconsistenet states. In network systems, <em>fail-stop</em> isn't the only model of failures. Nodes can follow a <em>fail-recover</em> fault model. Coordinator can recover and interfere with another recovery node. Failure in this case isn't crashing, but could be instead network interuptions.</p>
<h3 id="paxos----source">Paxos -- <a href="http://the-paper-trail.org/blog/consensus-protocols-paxos/">source</a>
</h3>
<ul>
<li>paxos adds <strong>ordering</strong> to the proposals to determine which proposals should be accepted.<ul>
<li>proposals are tagged with <strong>sequence numbers</strong>, used for total order</li>
<li>an acceptor guarantees that it will not accept any more proposals ordered before its newest proposal, instead returning its highest sequence number, which the proposer uses to figure out a sufficiently high sequence number for its next proposal</li>
<li>proposers draw from disjoint sets of sequence numbers for uniqueness (one practical way is using the address value of the proposer for tie breakers, paired with an integer)</li>
</ul>
</li>
<li>paxos introduces <strong>majorities</strong><ul>
<li>for two sets of majorities, there is at least one acceptor that agrees on both</li>
<li>therefore a third majority is guaranteed to contain information about the previous two majorities</li>
<li>by having majorities, paxos guarantees that every reply will contain at least one response from the previously agreed proposal</li>
<li>before any commit is sent from a proposer, it is known what the most recently agreed proposal was</li>
<li>all acceptors promise not to accept values part of sequences less than its current highest, preventing a proposer with a low sequence number from getting its proposal accepted</li>
</ul>
</li>
</ul>
<h3 id="phase-1a-prepare----source">Phase 1a: Prepare -- <a href="https://en.wikipedia.org/wiki/Paxos_(computer_science)#Basic_Paxos">source</a>
</h3>
<p>A Proposer (the leader) creates a proposal identified with a number N. This number must be greater than any previous proposal number used by this Proposer. Then, it sends a Prepare message containing this proposal to a Quorum of Acceptors. The Proposer decides who is in the Quorum.</p>
<h3 id="phase-1b-promise">Phase 1b: Promise</h3>
<p>If the proposal's number N is higher than any previous proposal number received from any Proposer by the Acceptor, then the Acceptor must return a promise to ignore all future proposals having a number less than N. If the Acceptor accepted a proposal at some point in the past, it must include the previous proposal number and previous value in its response to the Proposer.</p>
<p>Otherwise, the Acceptor can ignore the received proposal. It does not have to answer in this case for Paxos to work. However, for the sake of optimization, sending a denial (Nack) response would tell the Proposer that it can stop its attempt to create consensus with proposal N.</p>
<h3 id="phase-2a-accept-request">Phase 2a: Accept Request</h3>
<p>If a Proposer receives enough promises from a Quorum of Acceptors, it needs to set a value to its proposal. If any Acceptors had previously accepted any proposal, then they'll have sent their values to the Proposer, who now must set the value of its proposal to the value associated with the highest proposal number reported by the Acceptors. If none of the Acceptors had accepted a proposal up to this point, then the Proposer may choose any value for its proposal.</p>
<p>The Proposer sends an Accept Request message to a Quorum of Acceptors with the chosen value for its proposal.</p>
<h3 id="phase-2b-accepted">Phase 2b: Accepted</h3>
<p>If an Acceptor receives an Accept Request message for a proposal N, it must accept it if and only if it has not already promised to any prepare proposals having an identifier greater than N. In this case, it should register the corresponding value v and send an Accepted message to the Proposer and every Learner. Else, it can ignore the Accept Request.</p>
<h2 id="raft">Raft</h2>
<p>Same goal and efficiency as Paxos, but uses a different structure aimed to be more understandable for humans</p>
<ul><li>Raft separates key elements of consensus (leader election, log replication, safety) and enforces a stronger degree of coherency to reduce number states to be considered</li></ul>
    <div id="footer">
      Notes by <a href="https://github.com/kevintpeng">Kevin Peng</a>, Google intern.<br>
      Formerly Riot Games, Bloomberg, Apple &amp; Shopify.<br>
      Connect with me on <a href="https://www.linkedin.com/in/kevintpeng/">LinkedIn</a>.
    </div>
</body>
</html>
